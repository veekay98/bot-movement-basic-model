# -*- coding: utf-8 -*-
"""William_Chandler_Vignesh_Krishnan_Rohan_Tripathi_Project1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YDqDc6zNvD_mLZJmyixZ7OhQ0h3lnUez
"""

def explore_grid(n, matrix, num_aliens):                                                    # initialize function

  # Generate two random values within the range [1, n]
  random_value1 = random.randint(1, n-2)                                        # generate random y value
  random_value2 = random.randint(1, n-2)                                        # generate random x value

  starting_cell=matrix[random_value1][random_value2]                            # initialize open_cell
  # Open First Cell
  matrix[starting_cell['self'][0]][starting_cell['self'][1]]['value']=1         # Open First Cell
  current_open_cell=starting_cell                                               # initialize current_open_cell as open_cell
  possible_future_cells=[]                                                      # initialize possible_future_cells

  while True:
    if possible_future_cells:                                                 # if possible_future_cells not empty
      new_chosen_cell = random.choice(possible_future_cells)                  # initialize new_chosen_cell as random cell from possible_future_cells
      matrix[new_chosen_cell['self'][0]][new_chosen_cell['self'][1]]['value']=1 #open the new_chosen_cell
      current_open_cell=new_chosen_cell                                       # set current_open_cell to be the newest open cell
      possible_future_cells.remove(new_chosen_cell)                           # remove new_chosen_cell from possible_future_cells
    possible_future_cells = detect_possible_future_cells(current_open_cell, possible_future_cells, n) # add valid neighbors of current_open_cell to possible_future_cells
    if (starting_cell in possible_future_cells):
        possible_future_cells.remove(starting_cell)
    possible_future_cells = back_check_possible_future_cells(possible_future_cells) # remove invalid cells from possible_future_cells
    if (starting_cell in possible_future_cells):
        possible_future_cells.remove(starting_cell)

    if (len(possible_future_cells)==0):                                       # if no more possible_future_cells to add end while loop
      break

  dead_ends=find_dead_ends(matrix,n)
  matrix, des = open_half_of_dead_ends(matrix, dead_ends, n)

  aliens = initialize_aliens(num_aliens, matrix)
  for i in aliens:
    if matrix[i['self'][0]][i['self'][1]]['value']!='C':
      matrix[i['self'][0]][i['self'][1]]['value'] = 'A'

  crew_start_cell = random.choice(detect_open_cells(matrix))
  matrix[crew_start_cell[0]][crew_start_cell[1]]['value']= 'C'

  if (len(detect_open_neighbors_bot_1(matrix[crew_start_cell[0]][crew_start_cell[1]]))==0):
    modify_blocked_cells(matrix,crew_start_cell)

  return matrix, aliens, crew_start_cell                                                               # return completed matrix

def initialize_ship(n):                                                         # initialize initialize_ship function
  rows = n                                                                      # initialize number of rows
  cols = n                                                                      # initialize number of columns

  # Create a matrix of dictionaries
  matrix = []                                                                   # initialize matrix

  # Fill the matrix with dictionaries
  for i in range(rows):
      row = []
      for j in range(cols):
          left=j-1
          right=j+1
          top=i-1
          bottom=i+1
          #Testing for valid neighbor coordinates
          if (top<0):
              top=-1
          elif (bottom==n):
              bottom=-1
          elif (left<0):
              left=-1
          elif (right==n):
              right=-1
          # Create a dictionary with some key-value pairs
          dictionary = {
              'value': 0,
              'self': [i,j],
              'left': [i,left],
              'right': [i,right],
              'top': [top,j],
              'bottom': [bottom,j],
              'visited':'false',
              'prev':[]
          }
          row.append(dictionary)
      matrix.append(row)
  return matrix, n

import pandas as pd

def draw_ship_df(matrix):


  columns_123=[]
  rows_123=[]
  for i in range(len(matrix)):
    columns_123.append(i)
    rows_123.append(i)

  values_matrix=[]

  for i in range(len(matrix)):
    temp_row=[]
    for j in range(len(matrix)):
      elem=matrix[i][j]['value']
      edit_val=""
      if (elem==1):
        edit_val="o"
      elif (elem == 'C'):
        edit_val="C"
      elif (elem == 'A'):
        edit_val="A"
      elif (elem == 'C*'):
        edit_val="c"
      elif (elem == 'B'):
        edit_val="B"
      else:
        edit_val="x"
      temp_row.append(edit_val)
    values_matrix.append(temp_row)

  df = pd.DataFrame(values_matrix, columns=columns_123, index=rows_123)

  print(df.to_string())
  print("\n")

def detect_possible_future_cells(open_cell, possible_future_cells, n):
  arr=['left','right','top','bottom']
  for i in arr:

    counter=0

    if(open_cell[i][1]<0 or open_cell[i][1] == n):
      continue

    neighbor_cell = matrix[open_cell[i][0]][open_cell[i][1]]

    if (neighbor_cell['self'][0]==-1 or neighbor_cell['self'][1]==-1):
      continue

    open_neighbor_count=0

    for j in arr:
      if(neighbor_cell[j][1]<0 or neighbor_cell[j][1] == n):
        continue

      neighbor_cell_neighbor = matrix[neighbor_cell[j][0]][neighbor_cell[j][1]]

      if (neighbor_cell_neighbor['self'][0]==-1 or neighbor_cell_neighbor['self'][1]==-1):
        continue

      if (neighbor_cell_neighbor['value']==1):
        counter=counter+1

      if (neighbor_cell_neighbor['value']==1):
        open_neighbor_count=open_neighbor_count+1

    if (counter<2 and open_neighbor_count>=1):
      possible_future_cells.append(neighbor_cell)
  return possible_future_cells

def back_check_possible_future_cells(possible_future_cells):
  arr=['left','right','top','bottom']
  for cell in possible_future_cells:
    counter=0
    for j in arr:
      if(cell[j][1]<0 or cell[j][1] == n):
        continue
      neighbor_cell = matrix[cell[j][0]][cell[j][1]]
      if (neighbor_cell['value']==1):
        counter=counter+1
    if (counter>1):
      possible_future_cells.remove(cell)
  return possible_future_cells

def find_dead_ends(matrix, n):
  dead_ends=[]
  arr=['left','right','top','bottom']
  for row in matrix:
    for elem in row:
      if elem['value']==1:
        open_count=0
        for i in arr:
          if (elem[i][0]==-1 or elem[i][1]==-1 or elem[i][0]==n or elem[i][1]==n):
            continue;
          neighbor=matrix[elem[i][0]][elem[i][1]]
          if neighbor['value']==1:
            open_count=open_count+1
        if (open_count==1):
          dead_ends.append(elem)
  return dead_ends

def print_dead_ends(matrix, dead_ends):
  print('  ', end=' ')
  for i in range(n):
    print(i,end='  ')
  print("\n")
  j = 0
  for row in matrix:
    print(j, end=' ')
    j = j + 1
    for elem in row:
      if (elem not in dead_ends):
        print('N',end=' ')
      else:
        print('D',end=' ')
    print(" ")

def modify_blocked_cells(matrix,crew_cell):
  arr=['left','right','top','bottom']
  if len(detect_open_neighbors_bot_1(matrix[crew_cell[0]][crew_cell[1]]))==0:
    ch1=random.choice(arr)
    while(matrix[crew_cell[0]][crew_cell[1]][ch1][0]==-1 or matrix[crew_cell[0]][crew_cell[1]][ch1][1]==-1):
      arr.remove(ch1)
      ch1=random.choice(arr)
    x1=matrix[crew_cell[0]][crew_cell[1]][ch1][0]
    y1=matrix[crew_cell[0]][crew_cell[1]][ch1][1]
    matrix[x1][y1]['value']=1

def open_half_of_dead_ends(matrix, dead_ends, n):
  num_dead_ends=len(dead_ends)
  nodes_to_open=int(num_dead_ends/2+1)
  for i in range(nodes_to_open):
    try:
      dead_end_to_open = random.choice(dead_ends)
    except:
      continue
    arr=['left','right','top','bottom']
    valid_neighbors_to_open=[]
    for i in arr:
      if (dead_end_to_open[i][0]==-1 or dead_end_to_open[i][1]==-1 or dead_end_to_open[i][0]==n or dead_end_to_open[i][1]==n):
        continue
      neighbor=matrix[dead_end_to_open[i][0]][dead_end_to_open[i][1]]
      if (neighbor['value']==1):
        continue
      elif (neighbor['self'][0]==-1 or neighbor['self'][1]==-1 or neighbor['self'][0]==n or neighbor['self'][1]==n):
        continue
      else:
        valid_neighbors_to_open.append(neighbor['self'])
    if len(valid_neighbors_to_open)!=0:
      dead_end_neighbor_to_open = random.choice(valid_neighbors_to_open)
    matrix[dead_end_neighbor_to_open[0]][dead_end_neighbor_to_open[1]]['value']=1
    dead_ends.remove(dead_end_to_open)
  return matrix, dead_ends

def detect_open_neighbors_bot_1(current_cell):
  open_neighbors = []
  arr=['left','right','top','bottom']
  for i in arr:

    if (current_cell[i][0]==-1 or current_cell[i][1]==-1 or current_cell[i][0]==n or current_cell[i][1]==n):
        continue
    if matrix[current_cell[i][0]][current_cell[i][1]]['value']==0:
      continue
    else:
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])

  return open_neighbors

def detect_open_neighbors(current_cell):
  open_neighbors = []
  arr=['left','right','top','bottom']
  for i in arr:

    if (current_cell[i][0]==-1 or current_cell[i][1]==-1 or current_cell[i][0]==n or current_cell[i][1]==n):
        continue
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 1):
       open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 'C'):
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 'C*'):
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 'B'):
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])

  return open_neighbors

#adding this because the above code counts an alien on a crew mate as open but we don't want multiple aliens in the same cell
def detect_open_neighbors_for_aliens(current_cell):
  open_neighbors = []
  arr=['left','right','top','bottom']
  for i in arr:

    if (current_cell[i][0]==-1 or current_cell[i][1]==-1 or current_cell[i][0]==n or current_cell[i][1]==n):
        continue
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 1):
       open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 'C'):
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])
    if(matrix[current_cell[i][0]][current_cell[i][1]]['value'] == 'B'):
      open_neighbors.append(matrix[current_cell[i][0]][current_cell[i][1]]['self'])

  return open_neighbors

def detect_open_cells(matrix):
  open_cells = []
  for i in range(len(matrix)):
    for j in range(len(matrix)):
      if (matrix[i][j]['value'] == 1 or 'C'):
        open_cells.append(matrix[i][j]['self'])
  return open_cells

def initialize_aliens(n, matrix):
  aliens = []
  current_alien_start_cells = []
  for i in range(n):
    open_cells = detect_open_cells(matrix)
    alien_start_cell = random.choice(open_cells)
    while alien_start_cell in current_alien_start_cells:
      alien_start_cell = random.choice(open_cells)
    current_alien_start_cells.append(alien_start_cell)
    dictionary = {
      'alien_id' : i,
      'self': alien_start_cell,
      'open_neighbors' : detect_open_neighbors_for_aliens(matrix[alien_start_cell[0]][alien_start_cell[1]])
    }
    aliens.append(dictionary)
    matrix[alien_start_cell[0]][alien_start_cell[1]]['value'] = 'A'
  return aliens

def take_step(matrix, aliens, crew_start_cell, bot_cell, time_steps):
  import random
  import copy

  time_steps = time_steps + 1

  random.shuffle(aliens)
  for i in aliens:
    old_alien_location = i['self']
    if (matrix[crew_start_cell[0]][crew_start_cell[1]]['value'] == 'B'):
      crew_start_cell = random.choice(detect_open_cells(matrix))
      if (len(detect_open_neighbors_bot_1(matrix[crew_start_cell[0]][crew_start_cell[1]]))==0):
        modify_blocked_cells(matrix,crew_start_cell)
      matrix[crew_start_cell[0]][crew_start_cell[1]]['value'] = 'C'
    for j in aliens:
      if i['alien_id'] != j['alien_id']:
        if (matrix[i['self'][0]][i['self'][1]]['self'] == matrix[j['self'][0]][j['self'][1]]['self']):
          matrix[i['self'][0]][i['self'][1]]['value'] = 'A'
    if (matrix[i['self'][0]][i['self'][1]]['self'] == matrix[bot_cell[0]][bot_cell[1]]['self']):
      matrix[i['self'][0]][i['self'][1]]['value'] = 'B'
    if (matrix[i['self'][0]][i['self'][1]]['self'] == matrix[crew_start_cell[0]][crew_start_cell[1]]['self']):
      matrix[i['self'][0]][i['self'][1]]['value'] = 'C'
    else:
      matrix[i['self'][0]][i['self'][1]]['value'] = 1
    i['open_neighbors'] = detect_open_neighbors_for_aliens(matrix[i['self'][0]][i['self'][1]])
    try:
      i['self'] = random.choice(i['open_neighbors'])
    except:
      matrix[i['self'][0]][i['self'][1]]['value'] = 'A'
      continue
    if matrix[i['self'][0]][i['self'][1]]['value']=='C' or matrix[i['self'][0]][i['self'][1]]['value']=='C*':
      matrix[i['self'][0]][i['self'][1]]['value'] = 'C*'
    else:
      matrix[i['self'][0]][i['self'][1]]['value'] = 'A'
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", crew_start_cell, time_steps

  draw_ship_df(matrix)

  return "Status normal", crew_start_cell, time_steps

def detect_alien_free_neighbors(current_cell,aliens):
  open_n=detect_open_neighbors(current_cell)
  for alien in aliens:
    if alien['self'] in open_n:
      open_n.remove(alien['self'])
  return open_n

def detect_alien_free_cells(matrix,aliens):
  open_cells=detect_open_cells(matrix)
  for alien in aliens:
    if alien['self'] in open_cells:
      open_cells.remove(alien['self'])
  return open_cells

def create_bot(matrix,aliens):
  alien_free_cells=detect_alien_free_cells(matrix,aliens)
  bot_start_cell=random.choice(alien_free_cells)
  matrix[bot_start_cell[0]][bot_start_cell[1]]['value']='B'
  return bot_start_cell

def move_bot(bot_cell,path,aliens,crew_cell, time_steps):
  if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
    return "The bot was caught by the aliens", bot_cell, crew_cell, time_steps
  for next in path[1::]:
    matrix[bot_cell[0]][bot_cell[1]]['value']=1
    matrix[next[0]][next[1]]['value']='B'
    bot_cell=next
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", bot_cell, crew_cell, time_steps
    status, crew_cell, time_steps = take_step(matrix,aliens,crew_cell, bot_cell, time_steps)
    if status == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crew_cell, time_steps
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", bot_cell, crew_cell, time_steps
  return "The bot has rescued a crewmate!", bot_cell, crew_cell, time_steps

"""**BOT 1**"""

def breadth_first_search_bot_1(start_cell, matrix, aliens, crew_cell, vm_bfs_bot1, pm_bfs_bot1, time_steps):
  current_queue = [start_cell['self']]
  queue = [start_cell['self']]
  path = []                                                                     # entire sequence aka tree
  path1=[]                                                                      # shortest path
  temp=[]                                                                       # initialize path1
  while True:
    for x in current_queue:                                                     # iterate through current_queue
      if matrix[x[0]][x[1]]['value'] == 'C' or matrix[x[0]][x[1]]['value']=='C*':# checking if current element in queue is crewmate
        path.append(x)                                                          # adding crewmate cell to path
        path1.append(x)
        temp=x.copy()

        while pm_bfs_bot1[temp[0]][temp[1]]!=start_cell['self']:
          path1.insert(0,pm_bfs_bot1[temp[0]][temp[1]])
          temp=pm_bfs_bot1[temp[0]][temp[1]]

        path1.insert(0,start_cell['self'])
        return "found",path1,crew_cell, time_steps
      vm_bfs_bot1[x[0]][x[1]] = 'true'                                   # marking each visited cell
      path.append(x)                                                            # appending current node to tree
      open_neighbors = detect_open_neighbors_bot_1(matrix[x[0]][x[1]])                # detecting neighbors of current node

      while len(open_neighbors)==0:                                             # if bot is blocked
        status, crew_cell, time_steps = take_step(matrix,aliens,crew_cell, bot_cell, time_steps)                                # wait while aliens move
        if status == "The bot was caught by the aliens!":
          return "The bot was caught by the aliens!", path1, crew_cell, time_steps
        open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])              # check if path still blocked
      for y in open_neighbors:
        if y not in queue and vm_bfs_bot1[y[0]][y[1]]=='false':

          pm_bfs_bot1[y[0]][y[1]]=x                                          # asigning y as child of x
          queue.append(y)                                                       # adding y to queue
      queue.remove(x)
    current_queue = queue.copy()
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens", path1, crew_cell, time_steps

import random
D = 50
num_aliens = 50

results_array=[]

for _ in range(30):
  time_steps = 0
  num_crew_res=0

  visit_matrix_bot1 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append("false")
      visit_matrix_bot1.append(row)

  prev_matrix_bot1 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append([])
      prev_matrix_bot1.append(row)

  matrix, n = initialize_ship(D)
  matrix, aliens, crew_cell = explore_grid(n, matrix, num_aliens)
  bot_cell=create_bot(matrix,aliens)
  while (matrix[bot_cell[0]][bot_cell[1]]['value'] != 'A' and time_steps < 1000):
    print("initial ship:")
    draw_ship_df(matrix)
    res, path, crew_cell, time_steps  = breadth_first_search_bot_1(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, crew_cell, visit_matrix_bot1, prev_matrix_bot1, time_steps)
    print("-----------------------------------------------------------------------------------------------------")
    print("crew member was "+res+" via path",path)
    if len(path)!=0:
      print("Now moving Bot to rescue Crewmate...")
    final_outcome, bot_cell, crew_cell, time_steps = move_bot(bot_cell,path,aliens,crew_cell, time_steps)
    print(final_outcome)
    if final_outcome=="The bot has rescued a crewmate!":
      num_crew_res+=1

      visit_matrix_bot1 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append("false")
        visit_matrix_bot1.append(row)

      prev_matrix_bot1 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append([])
        prev_matrix_bot1.append(row)
      continue

    if res == "The bot was caught by the aliens" or final_outcome== 'The bot was caught by the aliens!' or final_outcome== 'The bot was caught by the aliens':
      print("NUMBER OF CREWMATES RESCUED",num_crew_res)
      results_array.append([num_crew_res, time_steps, "False"])
      break
  if time_steps == 1000:
    results_array.append([num_crew_res, time_steps,"True"])

print(results_array)
results_csv=pd.DataFrame(results_array)
results_csv.to_csv("bot1_timed_size50aliens50.csv")

"""<h4>bot 2</h4>"""

def breadth_first_search(start_cell, matrix, aliens, crew_cell, vm_bfs_bot2, pm_bfs_bot2, time_steps):
  current_queue = [start_cell['self']]
  queue = [start_cell['self']]
  path = []                                                                     # entire sequence aka tree
  path1=[]                                                                      # shortest path
  temp=[]                                                                       # initialize path1
  while True:
    for x in current_queue:                                                     # iterate through current_queue
      if matrix[x[0]][x[1]]['value'] == 'C' or matrix[x[0]][x[1]]['value']=='C*':# checking if current element in queue is crewmate
        path.append(x)                                                          # adding crewmate cell to path
        path1.append(x)
        temp=x.copy()
        while pm_bfs_bot2[temp[0]][temp[1]]!=start_cell['self']:             # creating shortest path list in path1
          path1.insert(0,pm_bfs_bot2[temp[0]][temp[1]])
          temp=pm_bfs_bot2[temp[0]][temp[1]]
        path1.insert(0,start_cell['self'])
        return "found",path1, crew_cell, vm_bfs_bot2, pm_bfs_bot2, time_steps
      vm_bfs_bot2[x[0]][x[1]] = 'true'
      path.append(x)                                                            # appending current node to tree
      open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])                # detecting neighbors of current node
      while len(open_neighbors)==0:                                             # if bot is blocked
        status, crew_cell, time_steps = take_step(matrix,aliens,crew_cell, bot_cell, time_steps)                                # wait while aliens move
        if status == "The bot was caught by the aliens!":
          return "The bot was caught by the aliens!", path1, crew_cell, vm_bfs_bot2, pm_bfs_bot2, time_steps
        open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])              # check if path still blocked
      for y in open_neighbors:
        if y not in queue and vm_bfs_bot2[y[0]][y[1]]=='false':
          pm_bfs_bot2[y[0]][y[1]]=x                                      # asigning y as child of x
          queue.append(y)                                                       # adding y to queue
      queue.remove(x)
    current_queue = queue.copy()
    if len(current_queue) == 0:
      status, crew_cell, time_steps = take_step(matrix,aliens,crew_cell, bot_cell, time_steps)
      if status == "The bot was caught by the aliens!":
        return "The bot was caught by the aliens!", path1, crew_cell, vm_bfs_bot2, pm_bfs_bot2, time_steps
      current_queue = [start_cell['self']]
      queue = [start_cell['self']]
      path = []                                                                     # entire sequence aka tree
      path1 = []                                                                      # shortest path
      temp = []
      for i in range(len(matrix)):
        for j in range(len(matrix)):
          pm_bfs_bot2[i][j] = []
          vm_bfs_bot2[i][j] = 'false'

    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens", path1, crew_cell, vm_bfs_bot2, pm_bfs_bot2, time_steps

def move_bot2(matrix,bot_cell,path,aliens,crew_start_cell,n, vm_movebot2, pm_movebot2, time_steps):
  crew_cell = crew_start_cell
  if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
    return "The bot was caught by the aliens", bot_cell, crew_cell, vm_movebot2, pm_movebot2, time_steps
  for next in path[1::]:
    matrix[bot_cell[0]][bot_cell[1]]['value']=1
    matrix[next[0]][next[1]]['value']='B'
    bot_cell=next
    status, crew_cell, time_steps = take_step(matrix, aliens, crew_cell, bot_cell, time_steps)
    if status == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_movebot2, pm_movebot2, time_steps
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_movebot2, pm_movebot2, time_steps
    for i in range(n):
      for j in range(n):
        vm_movebot2[i][j]='false'
    res,path, crew_cell, vm_mb2, pm_mb2, time_steps =breadth_first_search(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, crew_cell, vm_movebot2, pm_movebot2, time_steps)
    if res == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_mb2, pm_mb2, time_steps
  return "The bot has rescued a crewmate!", bot_cell, crew_cell, vm_mb2, pm_mb2, time_steps

import random
D = 50
num_aliens = 25

results_array=[]

for _ in range(30):
  time_steps = 0
  num_crew_res=0

  visit_matrix_bot2 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append("false")
      visit_matrix_bot2.append(row)

  prev_matrix_bot2 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append([])
      prev_matrix_bot2.append(row)

  matrix, n = initialize_ship(D)
  matrix, aliens, crew_cell = explore_grid(n, matrix, num_aliens)
  bot_cell=create_bot(matrix,aliens)
  while (matrix[bot_cell[0]][bot_cell[1]]['value'] != 'A' and time_steps < 1000):
    print("initial ship:")
    draw_ship_df(matrix)
    res, path, crew_cell, pm_bot2, vm_bot2, time_steps  = breadth_first_search(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, crew_cell, visit_matrix_bot2, prev_matrix_bot2, time_steps)
    print("-----------------------------------------------------------------------------------------------------")
    print("crew member was "+res+" via path",path)
    if len(path)!=0:
      print("Now moving Bot to rescue Crewmate...")
    final_outcome, bot_cell, crew_cell, pm_bot2_temp, vm_bot2_temp, time_steps = move_bot2(matrix,bot_cell,path,aliens,crew_cell,n, pm_bot2, vm_bot2, time_steps)
    print(final_outcome)
    if final_outcome=="The bot has rescued a crewmate!":
      num_crew_res+=1

      visit_matrix_bot2 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append("false")
        visit_matrix_bot2.append(row)

      prev_matrix_bot2 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append([])
        prev_matrix_bot2.append(row)
      continue
    if res == "The bot was caught by the aliens" or final_outcome== 'The bot was caught by the aliens!' or final_outcome== 'The bot was caught by the aliens':
      print("NUMBER OF CREWMATES RESCUED",num_crew_res)
      results_array.append([num_crew_res, time_steps, "False"])
      break
  if time_steps == 1000:
    results_array.append([num_crew_res, time_steps, "True"])

print(results_array)
results_csv=pd.DataFrame(results_array)
results_csv.to_csv("bot2_timed_size50_aliens5.csv")

"""<h4><b>Bot 3</b></h4>"""

def bfs_bot2from3(start_cell, matrix, aliens, crew_cell,time_steps):
  current_queue = [start_cell['self']]
  queue = [start_cell['self']]
  path = []                                                                     # entire sequence aka tree
  path1=[]                                                                      # shortest path
  temp=[]

  vm23 = []
  for i in range(len(matrix)):
      row = []
      for j in range(len(matrix)):
          row.append("false")
      vm23.append(row)

  pm23 = []
  for i in range(len(matrix)):
      row = []
      for j in range(len(matrix)):
          row.append([])
      pm23.append(row)
                                                                         # initialize path1
  while True:
    for x in current_queue:                                                     # iterate through current_queue
      if matrix[x[0]][x[1]]['value'] == 'C' or matrix[x[0]][x[1]]['value']=='C*':# checking if current element in queue is crewmate
        path.append(x)                                                          # adding crewmate cell to path
        path1.append(x)
        temp=x.copy()
        while pm23[temp[0]][temp[1]]!=start_cell['self']:             # creating shortest path list in path1
          path1.insert(0,pm23[temp[0]][temp[1]])
          temp=pm23[temp[0]][temp[1]]
        path1.insert(0,start_cell['self'])
        return "Found",path1, vm23, pm23, time_steps
      vm23[x[0]][x[1]] = 'true'
      path.append(x)                                                            # appending current node to tree
      open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])                # detecting neighbors of current node

      for y in open_neighbors:
        if y not in queue and vm23[y[0]][y[1]]=='false':
          pm23[y[0]][y[1]]=x                                      # asigning y as child of x
          queue.append(y)                                                       # adding y to queue
      queue.remove(x)
    current_queue = queue.copy()
    if len(current_queue) == 0:
      return "Not Found", path1, vm23, pm23, time_steps

#alien neighbors for bot 3
def detect_alien_neighbors(matrix, aliens):
  alien_neighbors=[]
  for alien_cell in aliens:
    for op_neigh in alien_cell['open_neighbors']:
      if op_neigh not in alien_neighbors:
        alien_neighbors.append(op_neigh)

  return alien_neighbors

#BFS Bot 3
def breadth_first_search_bot_3(start_cell, matrix, aliens, crew_start_cell, vm_bfs_bot3, pm_bfs_bot3, time_steps):
  crew_cell =crew_start_cell
  current_queue = [start_cell['self']]
  queue = [start_cell['self']]
  path = []                                                                     # entire sequence aka tree
  path1=[]                                                                      # shortest path
  temp=[]                                                                       # initialize path1
  while True:
    for x in current_queue:                                                     # iterate through current_queue
      if matrix[x[0]][x[1]]['value'] == 'C' or matrix[x[0]][x[1]]['value']=='C*':# checking if current element in queue is crewmate
        path.append(x)                                                          # adding crewmate cell to path
        path1.append(x)
        temp=x.copy()
        while pm_bfs_bot3[temp[0]][temp[1]]!=start_cell['self']:
          path1.insert(0,pm_bfs_bot3[temp[0]][temp[1]])
          temp=pm_bfs_bot3[temp[0]][temp[1]]
        path1.insert(0,start_cell['self'])
        return "found",path1, crew_cell, vm_bfs_bot3, pm_bfs_bot3,time_steps
      vm_bfs_bot3[x[0]][x[1]] = 'true'
      path.append(x)                                                            # appending current node to tree
      open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])
      forbidden_open_neighbors=detect_alien_neighbors(matrix, aliens)               # detecting neighbors of current node
      open_neighbors = [x for x in open_neighbors if x not in forbidden_open_neighbors]
      while len(open_neighbors)==0:                                             # if bot is blocked
        status, crew_start_cell,time_steps = take_step(matrix,aliens,crew_start_cell, bot_cell,time_steps)                                # wait while aliens move
        if status == "The bot was caught by the aliens!":
          return "The bot was caught by the aliens!", path1, crew_cell, vm_bfs_bot3, pm_bfs_bot3,time_steps
        open_neighbors = detect_open_neighbors(matrix[x[0]][x[1]])              # check if path still blocked
      for y in open_neighbors:
        if y not in queue and vm_bfs_bot3[y[0]][y[1]]=='false':
          pm_bfs_bot3[y[0]][y[1]]=x                                        # asigning y as child of x
          queue.append(y)                                                       # adding y to queue
      queue.remove(x)
    current_queue = queue.copy()
    if len(current_queue) == 0:
      search_status, path_ret, vm23_return, pm23_return,time_steps = bfs_bot2from3(start_cell,matrix,aliens, crew_cell,time_steps)
      if (search_status=="Found"):
        return "found", path_ret, crew_cell, vm23_return, pm23_return,time_steps

      status, crew_start_cell,time_steps = take_step(matrix,aliens,crew_start_cell, bot_cell,time_steps)
      if status == "The bot was caught by the aliens!":
        return "The bot was caught by the aliens!", path1, crew_cell, vm_bfs_bot3, pm_bfs_bot3,time_steps
      current_queue = [start_cell['self']]
      queue = [start_cell['self']]
      path = []                                                                     # entire sequence aka tree
      path1 = []                                                                      # shortest path
      temp = []
      for i in range(len(matrix)):
        for j in range(len(matrix)):
          pm_bfs_bot3[i][j] = []
          vm_bfs_bot3[i][j] = 'false'

    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", path1, crew_cell, vm_bfs_bot3, pm_bfs_bot3,time_steps

def move_bot3(matrix,bot_cell,path,aliens,crew_start_cell,n, vm_bot3_mb3, pm_bot3_mb3,time_steps):
  crew_cell = crew_start_cell

  if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
    return "The bot was caught by the aliens", bot_cell, crew_cell, vm_bot3_mb3, pm_bot3_mb3,time_steps
  for next in path[1::]:
    matrix[bot_cell[0]][bot_cell[1]]['value']=1
    matrix[next[0]][next[1]]['value']='B'
    bot_cell=next
    status, crew_cell,time_steps = take_step(matrix,aliens,crew_cell, bot_cell,time_steps)
    if status == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_bot3_mb3, pm_bot3_mb3,time_steps
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_bot3_mb3, pm_bot3_mb3,time_steps
    for i in range(n):
      for j in range(n):
        vm_bot3_mb3[i][j]='false'
    res, path, crew_cell, vm_return_bot3, pm_return_bot3,time_steps=breadth_first_search_bot_3(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, crew_cell, vm_bot3_mb3, pm_bot3_mb3,time_steps)
    if res == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, crew_cell, vm_return_bot3, pm_return_bot3,time_steps
  return "The bot has rescued a crewmate!", bot_cell, crew_cell, vm_return_bot3, pm_return_bot3,time_steps

import random
D = 50
num_aliens = 25

results_array=[]

for _ in range(30):
  num_crew_res=0
  time_steps=0
  visit_matrix_bot3 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append("false")
      visit_matrix_bot3.append(row)

  prev_matrix_bot3 = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append([])
      prev_matrix_bot3.append(row)

  matrix, n = initialize_ship(D)
  matrix, aliens, crew_cell = explore_grid(n, matrix, num_aliens)
  bot_cell=create_bot(matrix,aliens)
  crew_memebers_rescued = 0
  while (matrix[bot_cell[0]][bot_cell[1]]['value'] != 'A' and time_steps<1000):
    print("initial ship:")
    draw_ship_df(matrix)
    res,path, crew_cell, vm3, pm3,time_steps=breadth_first_search_bot_3(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, crew_cell, visit_matrix_bot3, prev_matrix_bot3,time_steps)
    print("-----------------------------------------------------------------------------------------------------")
    print("crew member was "+res+" via path",path)
    if len(path)!=0:
      print("Now moving Bot to rescue Crewmate...")
    final_outcome, bot_cell, crew_cell, vm_return3, pm_return3,time_steps = move_bot3(matrix,bot_cell,path,aliens,crew_cell,n, vm3, pm3,time_steps)
    print(final_outcome)
    if final_outcome=="The bot has rescued a crewmate!":
      num_crew_res+=1

      visit_matrix_bot3 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append("false")
        visit_matrix_bot3.append(row)

      prev_matrix_bot3 = []
      for i in range(D):
        row = []
        for j in range(D):
          row.append([])
        prev_matrix_bot3.append(row)
      continue
    if res == "The bot was caught by the aliens" or final_outcome== 'The bot was caught by the aliens!' or final_outcome== 'The bot was caught by the aliens':
      print("NUMBER OF CREWMATES RESCUED",num_crew_res)
      results_array.append([num_crew_res, time_steps, "False"])
      break
    if time_steps == 1000:
      results_array.append([num_crew_res, time_steps, "True"])

print(results_array)
results_csv=pd.DataFrame(results_array)
results_csv.to_csv("bot3_timed_size50_aliens5.csv")

"""<h4><b>Bot 4</b></h4>"""

def move_bot4(matrix,bot_cell,path,aliens,crew_start_cell,n, vm_bot4, pm_bot4,time_steps):
  crew_cell = crew_start_cell
  if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
    return "The bot was caught by the aliens", bot_cell, vm_bot4, pm_bot4, crew_cell,time_steps
  for next in path[1::]:
    matrix[bot_cell[0]][bot_cell[1]]['value']=1
    matrix[next[0]][next[1]]['value']='B'
    bot_cell=next
    status, crew_cell,time_steps = take_step(matrix,aliens, crew_cell, bot_cell,time_steps)
    if status == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, vm_bot4, pm_bot4, crew_cell,time_steps
    if matrix[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens!", bot_cell, vm_bot4, pm_bot4, crew_cell,time_steps
    for i in range(n):
      for j in range(n):
        vm_bot4[i][j]='false'
    res,path, vm_return, pm_return,time_steps=A_star_bot_4(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, vm_bot4, pm_bot4, crew_cell,time_steps)
    if res == "The bot was caught by the aliens!":
      return "The bot was caught by the aliens!", bot_cell, vm_return, pm_return, crew_cell,time_steps
  return "The bot has rescued a crewmate!", bot_cell, vm_return, pm_return, crew_cell,time_steps

def heuristic_bot_4(curr,crew,aliens):
  goal_hval=abs(curr[0]-crew[0])+abs(curr[1]-crew[1])
  alien_min1=abs(curr[0]-aliens[0]['self'][0])+abs(curr[1]-aliens[0]['self'][1])
  alien_min2=alien_min1
  alien_min1_pos=[aliens[0]['self'][0],aliens[0]['self'][1]]
  alien_min2_pos=[]
  for i,alien in enumerate(aliens):
    d1=abs(curr[0]-aliens[i]['self'][0])+abs(curr[1]-aliens[i]['self'][1])
    v1=[aliens[i]['self'][0],aliens[i]['self'][1]]
    if abs(curr[0]-aliens[i]['self'][0])+abs(curr[1]-aliens[i]['self'][1]) < alien_min1:
      alien_min2=alien_min1
      alien_min2_pos=alien_min1_pos
      alien_min1=abs(curr[0]-aliens[i]['self'][0])+abs(curr[1]-aliens[i]['self'][1])
      alien_min1_pos=[aliens[i]['self'][0],aliens[i]['self'][1]]
    elif abs(curr[0]-aliens[i]['self'][0])+abs(curr[1]-aliens[i]['self'][1]) < alien_min2:
      alien_min2=abs(curr[0]-aliens[i]['self'][0])+abs(curr[1]-aliens[i]['self'][1])
      alien_min2_pos=[aliens[i]['self'][0],aliens[i]['self'][1]]
  alien_hval=(alien_min1+alien_min2)//2
  hval=4*goal_hval+6*alien_hval
  return (hval,curr)

def check_if_visited(vm_check, a,b):
  if vm_check[a][b]=='true':
    return "true"
  else:
    return "false"

def draw_visited_matrix(vm_draw):
  for i in range(len(vm_draw)):
    for j in range(len(vm_draw)):
      if vm_draw[i][j]=='true':
        print(i,j,vm_draw[i][j])

def A_star_bot_4(start_cell, matrix1, aliens, vm_astar, pm_astar, crew_start_cell,time_steps):
  crew_cell = crew_start_cell
  current_queue = [start_cell['self']]
  queue = [start_cell['self']]
  path = []                                                                     # entire sequence aka tree
  path1=[]                                                                      # shortest path
  temp=[]
  pm_astar[start_cell['self'][0]][start_cell['self'][1]]=start_cell['self']                                         # initialize path1

  while True:
    for x in current_queue:
      if matrix1[x[0]][x[1]]['value'] == 'C' or matrix1[x[0]][x[1]]['value']=='C*':# checking if current element in queue is crewmate
        path.append(x)                                                          # adding crewmate cell to path
        path1.append(x)
        temp=x

        while pm_astar[temp[0]][temp[1]]!=start_cell['self']:             # creating shortest path list in path1
            path1.insert(0,pm_astar[temp[0]][temp[1]])
            temp=pm_astar[temp[0]][temp[1]]
        path1.insert(0,start_cell['self'])
        return "found",path1, vm_astar, pm_astar,time_steps

      vm_astar[x[0]][x[1]]= 'true'                                    # marking each visited cell
      path.append(x)                                                            # appending current node to tree
      open_neighbors = detect_open_neighbors(matrix1[x[0]][x[1]])                # detecting neighbors of current node

      on1=[]
      for ele in open_neighbors:
        on1.append(heuristic_bot_4(ele,crew_cell,aliens))
      on1.sort()

      on2=[]
      for ele in on1:
        temp1=ele[1]
        on2.append(temp1)

      while len(open_neighbors)==0:                                             # if bot is blocked
        status, crew_cel,time_steps = take_step(matrix1,aliens, crew_cell, bot_cell,time_steps)                                # wait while aliens move

        if status == "The bot was caught by the aliens!":
          return "The bot was caught by the aliens!", path1, vm_astar, pm_astar,time_steps

        open_neighbors = detect_open_neighbors(matrix1[x[0]][x[1]])              # check if path still blocked

      for y in on2:
        if (y==start_cell['self']):
          continue

        if y not in queue and check_if_visited(vm_astar, y[0],y[1])=='false':
          pm_astar[y[0]][y[1]]=x
          queue.append(y)                                                       # adding y to queue
      queue.remove(x)
      current_queue = queue.copy()

      if len(current_queue) == 0:
        status, crew_cell,time_steps = take_step(matrix1,aliens,crew_cell, bot_cell,time_steps)
        if status == "The bot was caught by the aliens!":
          return "The bot was caught by the aliens!", path1, vm_astar, pm_astar,time_steps

        current_queue = [start_cell['self']]
        queue = [start_cell['self']]
        path = []                                                                     # entire sequence aka tree
        path1 = []                                                                      # shortest path
        temp = []
        for i in range(len(matrix1)):
          for j in range(len(matrix1)):
            pm_astar[i][j] = []
            vm_astar[i][j] = 'false'

        A_star_bot_4(start_cell, matrix1, aliens, vm_astar, pm_astar, crew_cell,time_steps)


    if matrix1[bot_cell[0]][bot_cell[1]]['value']=='A' or matrix1[bot_cell[0]][bot_cell[1]]['value']=='C*':
      return "The bot was caught by the aliens", path1, vm_astar, pm_astar,time_steps

import random

D = 50
num_aliens = 25
results_array=[]
for _ in range(30):
  visit_matrix = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append("false")
      visit_matrix.append(row)

  prev_matrix = []
  for i in range(D):
      row = []
      for j in range(D):
          row.append([])
      prev_matrix.append(row)

  new_matrix = True
  if new_matrix:
    matrix, n = initialize_ship(D)
    matrix, aliens, crew_cell = explore_grid(n, matrix, num_aliens)

  bot_cell=create_bot(matrix,aliens)
  matrix[bot_cell[0]][bot_cell[1]]['prev']=[-1,-1]
  time_steps=0
  crew_members_rescued = 0

  iterations = 0

  while (matrix[bot_cell[0]][bot_cell[1]]['value'] != 'A' and time_steps<1000):
      print("initial ship:")

      draw_ship_df(matrix)
      res,path,vm2,pm2,time_steps=A_star_bot_4(matrix[bot_cell[0]][bot_cell[1]],matrix,aliens, visit_matrix, prev_matrix, crew_cell,time_steps)

      final_outcome, bot_cell, vmatrix, pmatrix, crew_cell,time_steps = move_bot4(matrix,bot_cell,path,aliens,crew_cell,n,vm2,pm2,time_steps)
      iterations = iterations + 1

      if final_outcome=="The bot has rescued a crewmate!":
        crew_members_rescued = crew_members_rescued + 1
        visit_matrix = []
        for i in range(D):
          row = []
          for j in range(D):
            row.append("false")
          visit_matrix.append(row)

        prev_matrix = []
        for i in range(D):
          row = []
          for j in range(D):
            row.append([])
          prev_matrix.append(row)
      if res == "The bot was caught by the aliens!" or final_outcome == "The bot was caught by the aliens!" or final_outcome== 'The bot was caught by the aliens':
        final_outcome = "The bot was caught by the aliens"
        print("NUMBER OF CREWMATES RESCUED",crew_members_rescued)
        results_array.append([crew_members_rescued, time_steps, "False"])
        break
      if time_steps == 1000:
        results_array.append([crew_members_rescued, time_steps, "True"])
      print("Iteration: ", iterations, "Crew members rescued: ", crew_members_rescued)
      print(final_outcome)

print("the result array is: ",results_array)
results_csv=pd.DataFrame(results_array)
results_csv.to_csv("bot4_timed_size50_aliens5.csv")